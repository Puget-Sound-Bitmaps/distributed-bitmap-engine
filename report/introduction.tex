\section{Introduction}
As datasets grow to be terabytes---or even petabytes---in size, performing
efficient queries on them can become prohibitively time-consuming if not done
efficiently. One method of improving query execution time is to use a
\term{bitmap index}, which is a collection of binary strings that represent
truth values pertaining to a relational database. In this paper we refer
to each string as a \term{bitmap vector}. Queries on such a bitmap index can
satisfy common database queries---such as an SQL \term{select-from-where}
queries---and are very efficient as they consist primarily of machine-level
bitwise operators. The lengths and quantities of vectors grow proportionally to
the size of the datasets.
\par
%
\begin{table}
    \centering
    \begin{tabular}{@{}r|rcll@{}}
        \toprule
        Tuple   & Salary (\$)  & Age & City    & Name  \\
        \midrule
        \(t_0\) & \num{65000}  & 20  & Tacoma  & Julia \\
        \(t_1\) & \num{25000}  & 76  & Spokane & Tim   \\
        \(t_2\) & \num{130000} & 42  & Seattle & Maria \\
        \bottomrule
    \end{tabular}
    \caption{Example of a Relational Database}
    \label{table:census-relational}
\end{table}
%
\begin{table}
    \centering
    \begin{tabular}{@{}r||cc|cc@{}}
        \toprule
                & \(S < \SI{100}[\$]{\kilo\nothing}\) & \(S \geq \SI{100}[\$]{\kilo\nothing}\) & \(Y < 50\) & \(Y \geq 50\) \\
        Tuple   & \(v_0\)    & \(v_1\)       & \(v_2\)    & \(v_3\)       \\
        \midrule
        \(t_0\) & 1          & 0             & 1          & 0             \\
        \(t_1\) & 1          & 0             & 0          & 0             \\
        \(t_2\) & 0          & 1             & 0          & 1             \\
        \bottomrule
    \end{tabular}
    \caption{Bitmap Index Representation of Table~\ref{table:census-relational}}
    \label{table:census-bitmap}
\end{table}
%
The purpose of our system (hereafter called DBIE) is to expand upon the
functionality of Chiu et al.'s bitmap engine by distributing a set of bitmap
vectors, and the work of executing bitmap queries, among multiple computers
(``machines''). A system comprising multiple machines is known as a
\term{distributed system}. Our approach was to handle vector input and query
requests from a database management system via a ``master'' process where both
the database management system and the master process are on the same machine.
In doing so, the master sends replicas of the vector(s) to two other distinct
machines (``slaves''). When satisfying queries, the master delegates work to
the slave(s) that have the requisite vector(s).
\par
The principal advantage of using a distributed system is that there is no
single point of failure. Should an individual slave machine fail the data can
be redistributed such that each vector is again replicated twice within the
system since each vector is backed up on a second machine. In a
\term{centralized system}, which contains only one machine and no backup, a
disk failure would require one to regenerate the entire index. By comparison,
a distributed system could return to service after minimal reorganization. Our
system is designed to be capable of recovering from single-slave failure at any
point during execution.
%
