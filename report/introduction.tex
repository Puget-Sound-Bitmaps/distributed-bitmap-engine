\section{Introduction}
As datasets grow to be terabytes---or even petabytes---in size, performing
efficient queries on them can become prohibitively time-consuming if not done
efficiently. An example of such a situation could be performing a query on US
census data (see Table~\ref{table:census-relational} for a small set of example
data). If we were to search for all Americans with salaries of at least
\SI{100000}[\$]{} who are also under the age of 50, we would have to parse each
line (tuple) in the database sequentially. Even on fast computers a read from
disk can take upwards of \SI{15}{\milli\second} and the US population is
roughly \num{326000000}. As a result, this query could take
\(\num{326 000 000} \times \SI{15}{\milli\second} = \SI{1400}{\hour}\)
which is just under two months; obviously, such slow queries are unacceptable.
\begin{table}[H]
    \centering
    \caption{Example of a Relational Database, \code{CENSUS}}
    \label{table:census-relational}
    \begin{tabular}{@{}r||rcll@{}}
        \toprule
        Tuple   & Salary (\$)  & Age & City    & Name  \\
        \midrule
        \(t_0\) & \num{65000}  & 20  & Tacoma  & Julia \\
        \(t_1\) & \num{25000}  & 76  & Spokane & Tim   \\
        \(t_2\) & \num{130000} & 42  & Seattle & Maria \\
        \bottomrule
    \end{tabular}
\end{table}
\par
One method of improving query execution time is to use a \term{bitmap index}. A
bitmap index is a collection of binary strings that represent truth values
pertaining to a relational database (see Tables~\ref{table:census-salary} and
\ref{table:census-age} for possible indexes of age and salary information in
Table~\ref{table:census-relational}). In this paper we refer to each string as
a \term{bitmap vector}. Queries on such a bitmap index can satisfy common
database queries---such as SQL \term{select-from-where} queries---and are very
efficient as they consist primarily of machine-level bitwise operators. The
lengths and quantities of vectors grow proportionally to the size of the
datasets.
\begin{table}[H]
    \centering
    \caption{Bitmap Index for Salary (\(S\), in thousands of dollars) in Table~\ref{table:census-relational}}
    \label{table:census-salary}
    \begin{tabular}{@{}r||c|c|c|c@{}}
        \toprule
                & \(S \leq 60\) & \(60 < S 100\) & \(100 < S \leq 300\) & \(300 \leq S\) \\
                & \(v_0\) & \(v_1\) & \(v_2\) & \(v_3\) \\
        \midrule
        \(t_0\) & 0          & 1             & 0          & 0             \\
        \(t_1\) & 1          & 0             & 0          & 0             \\
        \(t_2\) & 0          & 0             & 1          & 0             \\
        \bottomrule
    \end{tabular}
\end{table}
%
\begin{table}[H]
    \centering
    \caption{Bitmap Index for Age (\(A\)) in Table~\ref{table:census-relational}}
    \label{table:census-age}
    \begin{tabular}{@{}r||c|c|c|c@{}}
        \toprule
                & \(A < 18\) & \(18 \leq  A < 21\) & \(21 \leq A < 66\) & \(66 \leq A\) \\
                & \(v_4\) & \(v_5\) & \(v_6\) & \(v_7\) \\
        \midrule
        \(t_0\) & 0          & 1             & 0          & 0             \\
        \(t_1\) & 0          & 0             & 0          & 1             \\
        \(t_2\) & 0          & 0             & 1          & 0             \\
        \bottomrule
    \end{tabular}
\end{table}
\par
A system comprising multiple computers (\term{nodes}) is known as a
\term{distributed system}. In comparison, a system containing only one node is
called a \term{centralized system}. The principal advantages of using a
distributed system over a centralized system are twofold: first, there is no
single point of failure, and second, the storage capacity of the system in
aggregate can reach sized infeasible for a centralized system. Should an
individual node in a distributed system, the data can be redistributed such
that there is again a backup of all data in the system. Such resilience to
hardware (or software) failure cannot be be obtained in a centralized system,
and as a results, a failure would necessitate regenerating the entire index.
\par
The purpose of our system (hereafter called DBIE) is to expand upon the
functionality of Chiu, et al.'s bitmap engine by distributing a set of bitmap
vectors, and the work of executing bitmap queries, among multiple nodes. Our
system is designed to be capable of recovering from single-node failure at any
point during execution. Our approach was to handle vector input and query
requests from a database management system (DBMS) via a \term{master}
\term{process} (a program in execution) on the same node as the
DBMS. In order to store vectors and satisfy queries, the master sends
replicas of the vector to two distinct nodes (\term{slaves}), and to satisfy
queries, the master delegates work to the slaves that have the requisite
vectors.
\par
%
%
