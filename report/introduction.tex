\section{Introduction}
As datasets grow to be terabytes---or even petabytes---in size, performing
efficient queries on them can become prohibitively time-consuming if not done
efficiently. An example of such a situation could be performing a query on US
census data (see Table~\ref{table:census-relational} for a small set of example
data). If we were to search for all people making over \SI{150000}[\$]{} who
are under the age of 60, we would have to parse each line (tuple) in the
database sequentially. Even on fast computers a read from disk can take upwards
of \SI{15}{\milli\second} and the US population is roughly \num{326000000}.
As a result, this query could take
\(\num{326 000 000} \times \SI{15}{\milli\second} = \SI{1400}{\hour}\)
which is just under two months; obviously, such slow queries are unacceptable.
\par
One method of improving query execution time is to use a \term{bitmap index}. A
bitmap index is a collection of binary strings that represent truth values
pertaining to a relational database (see Table~\ref{table:census-bitmap} for a
possible index of Table~\ref{table:census-relational}). In this paper we refer
to each string as a \term{bitmap vector}. Queries on such a bitmap index can
satisfy common database queries---such as SQL \term{select-from-where}
queries---and are very efficient as they consist primarily of machine-level
bitwise operators. The lengths and quantities of vectors grow proportionally to
the size of the datasets.
\par
A system comprising multiple computers (\term{nodes}) is known as a
\term{distributed system}. In comparison, a system containing only one node is
called a \term{centralized system}. The principal advantages of using a
distributed system over a centralized system are twofold: first, there is no
single point of failure, and second, the storage capacity of the system in
aggregate can reach sized infeasible for a centralized system. Should an
individual node in a distributed system, the data can be redistributed such
that there is again a backup of all data in the system. Such resilience to
hardware (or software) failure cannot be be obtained in a centralized system,
and as a results, a failure would necessitate regenerating the entire index.
\par
The purpose of our system (hereafter called DBIE) is to expand upon the
functionality of Chiu, et al.'s bitmap engine by distributing a set of bitmap
vectors, and the work of executing bitmap queries, among multiple nodes. Our
system is designed to be capable of recovering from single-node failure at any
point during execution. Our approach was to handle vector input and query
requests from a database management system (DBMS) via a \term{master} process
on the same node as the DBMS. In order to store vectors and satisfy queries,
the master sends replicas of the vector to two distinct nodes (\term{slaves}),
and to satisfy queries, the master delegates work to the slaves that have the
requisite vectors.
\par
%
\begin{table}
    \centering
    \caption{Example of a Relational Database}
    \label{table:census-relational}
    \begin{tabular}{@{}r||rcll@{}}
        \toprule
        Tuple   & Salary (\$)  & Age & City    & Name  \\
        \midrule
        \(t_0\) & \num{65000}  & 20  & Tacoma  & Julia \\
        \(t_1\) & \num{25000}  & 76  & Spokane & Tim   \\
        \(t_2\) & \num{130000} & 42  & Seattle & Maria \\
        \bottomrule
    \end{tabular}
\end{table}
%
\begin{table}
    \centering
    \caption{Bitmap Index for Data in Table~\ref{table:census-relational}}
    \label{table:census-bitmap}
    \begin{tabular}{@{}r||cc|cc@{}}
        \toprule
                & \(S < \SI{100}[\$]{\kilo\nothing}\)
                & \(S \geq \SI{100}[\$]{\kilo\nothing}\)
                & \(Y < 50\) & \(Y \geq 50\) \\
        Tuple   & \(v_0\)    & \(v_1\)       & \(v_2\)    & \(v_3\)       \\
        \midrule
        \(t_0\) & 1          & 0             & 1          & 0             \\
        \(t_1\) & 1          & 0             & 0          & 0             \\
        \(t_2\) & 0          & 1             & 0          & 1             \\
        \bottomrule
    \end{tabular}
\end{table}
